{"version":3,"sources":["index.js","detectors/yin.js","detectors/amdf.js","detectors/acf2plus.js","detectors/dynamic_wavelet.js","detectors/macleod.js","tools/frequencies.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,AENA,AHSA,ADGA;AGRA,ADGA,AENA,AHSA,ADGA;AGRA,ADGA,AENA,AHSA,ADGA;AGRA,ADGA,AENA,ACHA,AJYA,ADGA;AGRA,ADGA,AENA,ACHA,AJYA,ADGA;AGRA,ADGA,AENA,ACHA,AJYA,ADGA;AGRA,ADGA,AENA,ACHA,AJYA,ADGA,AMlBA;AHUA,ADGA,AENA,ACHA,AJYA,ADGA,AMlBA;AHUA,ADGA,AENA,ACHA,AJYA,ADGA,AMlBA;AHUA,ADGA,AENA,ACHA,AJYA,ADGA,AMlBA;AHUA,ADGA,AENA,ACHA,AJYA,ADGA,AMlBA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA,AKfA;AHUA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;ACFA,AENA,ACHA,AJYA;ACFA,AENA,ACHA,AJYA;ACFA,AENA,ACHA,AJYA;ACFA,AENA,ACHA,AJYA;ACFA,AENA,ACHA,AJYA;ACFA,AENA,ACHA,AJYA;ACFA,AENA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar yin_1 = require(\"./detectors/yin\");\nexports.YIN = yin_1.YIN;\nvar amdf_1 = require(\"./detectors/amdf\");\nexports.AMDF = amdf_1.AMDF;\nvar acf2plus_1 = require(\"./detectors/acf2plus\");\nexports.ACF2PLUS = acf2plus_1.ACF2PLUS;\nvar dynamic_wavelet_1 = require(\"./detectors/dynamic_wavelet\");\nexports.DynamicWavelet = dynamic_wavelet_1.DynamicWavelet;\nvar macleod_1 = require(\"./detectors/macleod\");\nexports.Macleod = macleod_1.Macleod;\nvar frequencies_1 = require(\"./tools/frequencies\");\nexports.frequencies = frequencies_1.frequencies;\nexports.default = {\n    YIN: yin_1.YIN,\n    AMDF: amdf_1.AMDF,\n    ACF2PLUS: acf2plus_1.ACF2PLUS,\n    DynamicWavelet: dynamic_wavelet_1.DynamicWavelet,\n    Macleod: macleod_1.Macleod,\n    frequencies: frequencies_1.frequencies,\n};\n","\n/*\n  Copyright (C) 2003-2009 Paul Brossier <piem@aubio.org>\n  This file is part of aubio.\n  aubio is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  aubio is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n  along with aubio.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_YIN_PARAMS = {\n    threshold: 0.1,\n    sampleRate: 44100,\n    probabilityThreshold: 0.1,\n};\nfunction YIN(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_YIN_PARAMS), params);\n    var threshold = config.threshold, sampleRate = config.sampleRate, probabilityThreshold = config.probabilityThreshold;\n    return function YINDetector(float32AudioBuffer) {\n        // Set buffer size to the highest power of two below the provided buffer's length.\n        var bufferSize;\n        for (bufferSize = 1; bufferSize < float32AudioBuffer.length; bufferSize *= 2)\n            ;\n        bufferSize /= 2;\n        // Set up the yinBuffer as described in step one of the YIN paper.\n        var yinBufferLength = bufferSize / 2;\n        var yinBuffer = new Float32Array(yinBufferLength);\n        var probability = 0, tau;\n        // Compute the difference function as described in step 2 of the YIN paper.\n        for (var t = 0; t < yinBufferLength; t++) {\n            yinBuffer[t] = 0;\n        }\n        for (var t = 1; t < yinBufferLength; t++) {\n            for (var i = 0; i < yinBufferLength; i++) {\n                var delta = float32AudioBuffer[i] - float32AudioBuffer[i + t];\n                yinBuffer[t] += delta * delta;\n            }\n        }\n        // Compute the cumulative mean normalized difference as described in step 3 of the paper.\n        yinBuffer[0] = 1;\n        yinBuffer[1] = 1;\n        var runningSum = 0;\n        for (var t = 1; t < yinBufferLength; t++) {\n            runningSum += yinBuffer[t];\n            yinBuffer[t] *= t / runningSum;\n        }\n        // Compute the absolute threshold as described in step 4 of the paper.\n        // Since the first two positions in the array are 1,\n        // we can start at the third position.\n        for (tau = 2; tau < yinBufferLength; tau++) {\n            if (yinBuffer[tau] < threshold) {\n                while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n                    tau++;\n                }\n                // found tau, exit loop and return\n                // store the probability\n                // From the YIN paper: The threshold determines the list of\n                // candidates admitted to the set, and can be interpreted as the\n                // proportion of aperiodic power tolerated\n                // within a periodic signal.\n                //\n                // Since we want the periodicity and and not aperiodicity:\n                // periodicity = 1 - aperiodicity\n                probability = 1 - yinBuffer[tau];\n                break;\n            }\n        }\n        // if no pitch found, return null.\n        if (tau === yinBufferLength || yinBuffer[tau] >= threshold) {\n            return null;\n        }\n        // If probability too low, return -1.\n        if (probability < probabilityThreshold) {\n            return null;\n        }\n        /**\n         * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n         * value using parabolic interpolation. This is needed to detect higher\n         * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n         * for more background\n         * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n         */\n        var betterTau, x0, x2;\n        if (tau < 1) {\n            x0 = tau;\n        }\n        else {\n            x0 = tau - 1;\n        }\n        if (tau + 1 < yinBufferLength) {\n            x2 = tau + 1;\n        }\n        else {\n            x2 = tau;\n        }\n        if (x0 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x2]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x2;\n            }\n        }\n        else if (x2 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x0]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x0;\n            }\n        }\n        else {\n            var s0 = yinBuffer[x0];\n            var s1 = yinBuffer[tau];\n            var s2 = yinBuffer[x2];\n            // fixed AUBIO implementation, thanks to Karl Helgason:\n            // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n            betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n        }\n        return sampleRate / betterTau;\n    };\n}\nexports.YIN = YIN;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_AMDF_PARAMS = {\n    sampleRate: 44100,\n    minFrequency: 82,\n    maxFrequency: 1000,\n    ratio: 5,\n    sensitivity: 0.1,\n};\nfunction AMDF(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_AMDF_PARAMS), params);\n    var sampleRate = config.sampleRate;\n    var minFrequency = config.minFrequency;\n    var maxFrequency = config.maxFrequency;\n    var sensitivity = config.sensitivity;\n    var ratio = config.ratio;\n    var amd = [];\n    /* Round in such a way that both exact minPeriod as\n     exact maxPeriod lie inside the rounded span minPeriod-maxPeriod,\n     thus ensuring that minFrequency and maxFrequency can be found\n     even in edge cases */\n    var maxPeriod = Math.ceil(sampleRate / minFrequency);\n    var minPeriod = Math.floor(sampleRate / maxFrequency);\n    return function AMDFDetector(float32AudioBuffer) {\n        var maxShift = float32AudioBuffer.length;\n        var t = 0;\n        var minval = Infinity;\n        var maxval = -Infinity;\n        var frames1, frames2, calcSub, i, j, u, aux1, aux2;\n        // Find the average magnitude difference for each possible period offset.\n        for (i = 0; i < maxShift; i++) {\n            if (minPeriod <= i && i <= maxPeriod) {\n                for (aux1 = 0, aux2 = i, t = 0, frames1 = [], frames2 = []; aux1 < maxShift - i; t++, aux2++, aux1++) {\n                    frames1[t] = float32AudioBuffer[aux1];\n                    frames2[t] = float32AudioBuffer[aux2];\n                }\n                // Take the difference between these frames.\n                var frameLength = frames1.length;\n                calcSub = [];\n                for (u = 0; u < frameLength; u++) {\n                    calcSub[u] = frames1[u] - frames2[u];\n                }\n                // Sum the differences.\n                var summation = 0;\n                for (u = 0; u < frameLength; u++) {\n                    summation += Math.abs(calcSub[u]);\n                }\n                amd[i] = summation;\n            }\n        }\n        for (j = minPeriod; j < maxPeriod; j++) {\n            if (amd[j] < minval)\n                minval = amd[j];\n            if (amd[j] > maxval)\n                maxval = amd[j];\n        }\n        var cutoff = Math.round(sensitivity * (maxval - minval) + minval);\n        for (j = minPeriod; j <= maxPeriod && amd[j] > cutoff; j++)\n            ;\n        var searchLength = minPeriod / 2;\n        minval = amd[j];\n        var minpos = j;\n        for (i = j - 1; i < j + searchLength && i <= maxPeriod; i++) {\n            if (amd[i] < minval) {\n                minval = amd[i];\n                minpos = i;\n            }\n        }\n        if (Math.round(amd[minpos] * ratio) < maxval) {\n            return sampleRate / minpos;\n        }\n        else {\n            return null;\n        }\n    };\n}\nexports.AMDF = AMDF;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_PARAMS = {\n    sampleRate: 44100,\n};\nfunction ACF2PLUS(params) {\n    if (params === void 0) { params = DEFAULT_PARAMS; }\n    var config = __assign(__assign({}, DEFAULT_PARAMS), params);\n    var sampleRate = config.sampleRate;\n    // Implements the ACF2+ algorithm\n    return function ACF2PLUSDetector(float32AudioBuffer) {\n        var maxShift = float32AudioBuffer.length;\n        var rms = 0;\n        var i, j, u, tmp;\n        for (i = 0; i < maxShift; i++) {\n            tmp = float32AudioBuffer[i];\n            rms += tmp * tmp;\n        }\n        rms = Math.sqrt(rms / maxShift);\n        if (rms < 0.01)\n            // not enough signal\n            return -1;\n        /* Trimming cuts the edges of the signal so that it starts and ends near zero.\n         This is used to neutralize an inherent instability of the ACF version I use.*/\n        var aux1 = 0;\n        var aux2 = maxShift - 1;\n        var thres = 0.2;\n        for (i = 0; i < maxShift / 2; i++)\n            if (Math.abs(float32AudioBuffer[i]) < thres) {\n                aux1 = i;\n                break;\n            }\n        for (i = 1; i < maxShift / 2; i++)\n            if (Math.abs(float32AudioBuffer[maxShift - i]) < thres) {\n                aux2 = maxShift - i;\n                break;\n            }\n        var frames = float32AudioBuffer.slice(aux1, aux2);\n        var framesLength = frames.length;\n        var calcSub = new Array(framesLength).fill(0);\n        for (i = 0; i < framesLength; i++)\n            for (j = 0; j < framesLength - i; j++)\n                calcSub[i] = calcSub[i] + frames[j] * frames[j + i];\n        u = 0;\n        while (calcSub[u] > calcSub[u + 1])\n            u++;\n        var maxval = -1, maxpos = -1;\n        for (i = u; i < framesLength; i++) {\n            if (calcSub[i] > maxval) {\n                maxval = calcSub[i];\n                maxpos = i;\n            }\n        }\n        var T0 = maxpos;\n        /* Interpolation is parabolic interpolation. It helps with precision.\n         We suppose that a parabola pass through the three points that comprise the peak.\n         'a' and 'b' are the unknowns from the linear equation system\n         and b/(2a) is the \"error\" in the abscissa.\n         y1,y2,y3 are the ordinates.*/\n        var y1 = calcSub[T0 - 1], y2 = calcSub[T0], y3 = calcSub[T0 + 1];\n        var a = (y1 + y3 - 2 * y2) / 2;\n        var b = (y3 - y1) / 2;\n        if (a)\n            T0 = T0 - b / (2 * a);\n        return sampleRate / T0;\n    };\n}\nexports.ACF2PLUS = ACF2PLUS;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MAX_FLWT_LEVELS = 6;\nvar MAX_F = 3000;\nvar DIFFERENCE_LEVELS_N = 3;\nvar MAXIMA_THRESHOLD_RATIO = 0.75;\nvar DEFAULT_DYNAMIC_WAVELET_CONFIG = {\n    sampleRate: 44100,\n};\nfunction DynamicWavelet(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_DYNAMIC_WAVELET_CONFIG), params);\n    var sampleRate = config.sampleRate;\n    return function DynamicWaveletDetector(float32AudioBuffer) {\n        var mins = [];\n        var maxs = [];\n        var bufferLength = float32AudioBuffer.length;\n        var freq = null;\n        var theDC = 0;\n        var minValue = 0;\n        var maxValue = 0;\n        // Compute max amplitude, amplitude threshold, and the DC.\n        for (var i = 0; i < bufferLength; i++) {\n            var sample = float32AudioBuffer[i];\n            theDC = theDC + sample;\n            maxValue = Math.max(maxValue, sample);\n            minValue = Math.min(minValue, sample);\n        }\n        theDC /= bufferLength;\n        minValue -= theDC;\n        maxValue -= theDC;\n        var amplitudeMax = maxValue > -1 * minValue ? maxValue : -1 * minValue;\n        var amplitudeThreshold = amplitudeMax * MAXIMA_THRESHOLD_RATIO;\n        // levels, start without downsampling...\n        var curLevel = 0;\n        var curModeDistance = -1;\n        var curSamNb = float32AudioBuffer.length;\n        var delta, nbMaxs, nbMins;\n        // Search:\n        while (true) {\n            delta = ~~(sampleRate / (Math.pow(2, curLevel) * MAX_F));\n            if (curSamNb < 2)\n                break;\n            var dv = void 0;\n            var previousDV = -1000;\n            var lastMinIndex = -1000000;\n            var lastMaxIndex = -1000000;\n            var findMax = false;\n            var findMin = false;\n            nbMins = 0;\n            nbMaxs = 0;\n            for (var i = 2; i < curSamNb; i++) {\n                var si = float32AudioBuffer[i] - theDC;\n                var si1 = float32AudioBuffer[i - 1] - theDC;\n                if (si1 <= 0 && si > 0)\n                    findMax = true;\n                if (si1 >= 0 && si < 0)\n                    findMin = true;\n                // min or max ?\n                dv = si - si1;\n                if (previousDV > -1000) {\n                    if (findMin && previousDV < 0 && dv >= 0) {\n                        // minimum\n                        if (Math.abs(si) >= amplitudeThreshold) {\n                            if (i > lastMinIndex + delta) {\n                                mins[nbMins++] = i;\n                                lastMinIndex = i;\n                                findMin = false;\n                            }\n                        }\n                    }\n                    if (findMax && previousDV > 0 && dv <= 0) {\n                        // maximum\n                        if (Math.abs(si) >= amplitudeThreshold) {\n                            if (i > lastMaxIndex + delta) {\n                                maxs[nbMaxs++] = i;\n                                lastMaxIndex = i;\n                                findMax = false;\n                            }\n                        }\n                    }\n                }\n                previousDV = dv;\n            }\n            if (nbMins === 0 && nbMaxs === 0) {\n                // No best distance found!\n                break;\n            }\n            var d = void 0;\n            var distances = [];\n            for (var i = 0; i < curSamNb; i++) {\n                distances[i] = 0;\n            }\n            for (var i = 0; i < nbMins; i++) {\n                for (var j = 1; j < DIFFERENCE_LEVELS_N; j++) {\n                    if (i + j < nbMins) {\n                        d = Math.abs(mins[i] - mins[i + j]);\n                        distances[d] += 1;\n                    }\n                }\n            }\n            var bestDistance = -1;\n            var bestValue = -1;\n            for (var i = 0; i < curSamNb; i++) {\n                var summed = 0;\n                for (var j = -1 * delta; j <= delta; j++) {\n                    if (i + j >= 0 && i + j < curSamNb) {\n                        summed += distances[i + j];\n                    }\n                }\n                if (summed === bestValue) {\n                    if (i === 2 * bestDistance) {\n                        bestDistance = i;\n                    }\n                }\n                else if (summed > bestValue) {\n                    bestValue = summed;\n                    bestDistance = i;\n                }\n            }\n            // averaging\n            var distAvg = 0;\n            var nbDists = 0;\n            for (var j = -delta; j <= delta; j++) {\n                if (bestDistance + j >= 0 && bestDistance + j < bufferLength) {\n                    var nbDist = distances[bestDistance + j];\n                    if (nbDist > 0) {\n                        nbDists += nbDist;\n                        distAvg += (bestDistance + j) * nbDist;\n                    }\n                }\n            }\n            // This is our mode distance.\n            distAvg /= nbDists;\n            // Continue the levels?\n            if (curModeDistance > -1) {\n                if (Math.abs(distAvg * 2 - curModeDistance) <= 2 * delta) {\n                    // two consecutive similar mode distances : ok !\n                    freq = sampleRate / (Math.pow(2, curLevel - 1) * curModeDistance);\n                    break;\n                }\n            }\n            // not similar, continue next level;\n            curModeDistance = distAvg;\n            curLevel++;\n            if (curLevel >= MAX_FLWT_LEVELS || curSamNb < 2) {\n                break;\n            }\n            //do not modify original audio buffer, make a copy buffer, if\n            //downsampling is needed (only once).\n            var newFloat32AudioBuffer = float32AudioBuffer.subarray(0);\n            if (curSamNb === distances.length) {\n                newFloat32AudioBuffer = new Float32Array(curSamNb / 2);\n            }\n            for (var i = 0; i < curSamNb / 2; i++) {\n                newFloat32AudioBuffer[i] =\n                    (float32AudioBuffer[2 * i] + float32AudioBuffer[2 * i + 1]) / 2;\n            }\n            float32AudioBuffer = newFloat32AudioBuffer;\n            curSamNb /= 2;\n        }\n        return freq;\n    };\n}\nexports.DynamicWavelet = DynamicWavelet;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_MACLEOD_PARAMS = {\n    bufferSize: 1024,\n    cutoff: 0.97,\n    sampleRate: 44100,\n};\nfunction Macleod(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_MACLEOD_PARAMS), params);\n    var bufferSize = config.bufferSize, cutoff = config.cutoff, sampleRate = config.sampleRate;\n    /**\n     * For performance reasons, peaks below this cutoff are not even considered.\n     */\n    var SMALL_CUTOFF = 0.5;\n    /**\n     * Pitch annotations below this threshold are considered invalid, they are\n     * ignored.\n     */\n    var LOWER_PITCH_CUTOFF = 80;\n    /**\n     * Contains a normalized square difference function value for each delay\n     * (tau).\n     */\n    var nsdf = new Float32Array(bufferSize);\n    /**\n     * Contains a sum of squares of the Buffer, for improving performance\n     * (avoids redoing math in the normalized square difference function)\n     */\n    var squaredBufferSum = new Float32Array(bufferSize);\n    /**\n     * The x and y coordinate of the top of the curve (nsdf).\n     */\n    var turningPointX;\n    var turningPointY;\n    /**\n     * A list with minimum and maximum values of the nsdf curve.\n     */\n    var maxPositions = [];\n    /**\n     * A list of estimates of the period of the signal (in samples).\n     */\n    var periodEstimates = [];\n    /**\n     * A list of estimates of the amplitudes corresponding with the period\n     * estimates.\n     */\n    var ampEstimates = [];\n    /**\n     * Implements the normalized square difference function. See section 4 (and\n     * the explanation before) in the MPM article. This calculation can be\n     * optimized by using an FFT. The results should remain the same.\n     */\n    function normalizedSquareDifference(float32AudioBuffer) {\n        var acf;\n        var divisorM;\n        squaredBufferSum[0] = float32AudioBuffer[0] * float32AudioBuffer[0];\n        for (var i = 1; i < float32AudioBuffer.length; i += 1) {\n            squaredBufferSum[i] =\n                float32AudioBuffer[i] * float32AudioBuffer[i] + squaredBufferSum[i - 1];\n        }\n        for (var tau = 0; tau < float32AudioBuffer.length; tau++) {\n            acf = 0;\n            divisorM =\n                squaredBufferSum[float32AudioBuffer.length - 1 - tau] +\n                    squaredBufferSum[float32AudioBuffer.length - 1] -\n                    squaredBufferSum[tau];\n            for (var i = 0; i < float32AudioBuffer.length - tau; i++) {\n                acf += float32AudioBuffer[i] * float32AudioBuffer[i + tau];\n            }\n            nsdf[tau] = (2 * acf) / divisorM;\n        }\n    }\n    /**\n     * Finds the x value corresponding with the peak of a parabola.\n     * Interpolates between three consecutive points centered on tau.\n     */\n    function parabolicInterpolation(tau) {\n        var nsdfa = nsdf[tau - 1], nsdfb = nsdf[tau], nsdfc = nsdf[tau + 1], bValue = tau, bottom = nsdfc + nsdfa - 2 * nsdfb;\n        if (bottom === 0) {\n            turningPointX = bValue;\n            turningPointY = nsdfb;\n        }\n        else {\n            var delta = nsdfa - nsdfc;\n            turningPointX = bValue + delta / (2 * bottom);\n            turningPointY = nsdfb - (delta * delta) / (8 * bottom);\n        }\n    }\n    // Finds the highest value between each pair of positive zero crossings.\n    function peakPicking() {\n        var pos = 0;\n        var curMaxPos = 0;\n        // find the first negative zero crossing.\n        while (pos < (nsdf.length - 1) / 3 && nsdf[pos] > 0) {\n            pos++;\n        }\n        // loop over all the values below zero.\n        while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n            pos++;\n        }\n        // can happen if output[0] is NAN\n        if (pos == 0) {\n            pos = 1;\n        }\n        while (pos < nsdf.length - 1) {\n            if (nsdf[pos] > nsdf[pos - 1] && nsdf[pos] >= nsdf[pos + 1]) {\n                if (curMaxPos == 0) {\n                    // the first max (between zero crossings)\n                    curMaxPos = pos;\n                }\n                else if (nsdf[pos] > nsdf[curMaxPos]) {\n                    // a higher max (between the zero crossings)\n                    curMaxPos = pos;\n                }\n            }\n            pos++;\n            // a negative zero crossing\n            if (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                // if there was a maximum add it to the list of maxima\n                if (curMaxPos > 0) {\n                    maxPositions.push(curMaxPos);\n                    curMaxPos = 0; // clear the maximum position, so we start\n                    // looking for a new ones\n                }\n                while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                    pos++; // loop over all the values below zero\n                }\n            }\n        }\n        if (curMaxPos > 0) {\n            maxPositions.push(curMaxPos);\n        }\n    }\n    return function Macleod(float32AudioBuffer) {\n        // 0. Clear old results.\n        var pitch;\n        maxPositions = [];\n        periodEstimates = [];\n        ampEstimates = [];\n        // 1. Calculute the normalized square difference for each Tau value.\n        normalizedSquareDifference(float32AudioBuffer);\n        // 2. Peak picking time: time to pick some peaks.\n        peakPicking();\n        var highestAmplitude = -Infinity;\n        for (var i = 0; i < maxPositions.length; i++) {\n            var tau = maxPositions[i];\n            // make sure every annotation has a probability attached\n            highestAmplitude = Math.max(highestAmplitude, nsdf[tau]);\n            if (nsdf[tau] > SMALL_CUTOFF) {\n                // calculates turningPointX and Y\n                parabolicInterpolation(tau);\n                // store the turning points\n                ampEstimates.push(turningPointY);\n                periodEstimates.push(turningPointX);\n                // remember the highest amplitude\n                highestAmplitude = Math.max(highestAmplitude, turningPointY);\n            }\n        }\n        if (periodEstimates.length) {\n            // use the overall maximum to calculate a cutoff.\n            // The cutoff value is based on the highest value and a relative\n            // threshold.\n            var actualCutoff = cutoff * highestAmplitude;\n            var periodIndex = 0;\n            for (var i = 0; i < ampEstimates.length; i++) {\n                if (ampEstimates[i] >= actualCutoff) {\n                    periodIndex = i;\n                    break;\n                }\n            }\n            var period = periodEstimates[periodIndex], pitchEstimate = sampleRate / period;\n            if (pitchEstimate > LOWER_PITCH_CUTOFF) {\n                pitch = pitchEstimate;\n            }\n            else {\n                pitch = -1;\n            }\n        }\n        else {\n            // no pitch detected.\n            pitch = -1;\n        }\n        return {\n            probability: highestAmplitude,\n            freq: pitch,\n        };\n    };\n}\nexports.Macleod = Macleod;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_FREQUENCIES_PARAMS = {\n    tempo: 120,\n    quantization: 4,\n    sampleRate: 44100,\n};\nfunction pitchConsensus(detectors, chunk) {\n    var pitches = detectors\n        .map(function (fn) { return fn(chunk); })\n        .filter(function (value) { return value !== null; })\n        .sort(function (a, b) { return a - b; });\n    // In the case of one pitch, return it.\n    if (pitches.length === 1) {\n        return pitches[0];\n        // In the case of two pitches, return the geometric mean if they\n        // are close to each other, and the lower pitch otherwise.\n    }\n    else if (pitches.length === 2) {\n        var first = pitches[0], second = pitches[1];\n        return first * 2 > second ? Math.sqrt(first * second) : first;\n        // In the case of three or more pitches, filter away the extremes\n        // if they are very extreme, then take the geometric mean.\n    }\n    else {\n        var first = pitches[0];\n        var second = pitches[1];\n        var secondToLast = pitches[pitches.length - 2];\n        var last = pitches[pitches.length - 1];\n        var filtered1 = first * 2 > second ? pitches : pitches.slice(1);\n        var filtered2 = secondToLast * 2 > last ? filtered1 : filtered1.slice(0, -1);\n        return Math.pow(filtered2.reduce(function (t, p) { return t * p; }, 1), 1 / filtered2.length);\n    }\n}\nfunction frequencies(detector, float32AudioBuffer, options) {\n    if (options === void 0) { options = {}; }\n    var config = __assign(__assign({}, exports.DEFAULT_FREQUENCIES_PARAMS), options);\n    var tempo = config.tempo, quantization = config.quantization, sampleRate = config.sampleRate;\n    var bufferLength = float32AudioBuffer.length;\n    var chunkSize = Math.round((sampleRate * 60) / (quantization * tempo));\n    var getPitch;\n    if (Array.isArray(detector)) {\n        getPitch = pitchConsensus.bind(null, detector);\n    }\n    else {\n        getPitch = detector;\n    }\n    var pitches = [];\n    for (var i = 0, max = bufferLength - chunkSize; i <= max; i += chunkSize) {\n        var chunk = float32AudioBuffer.slice(i, i + chunkSize);\n        var pitch = getPitch(chunk);\n        pitches.push(pitch);\n    }\n    return pitches;\n}\nexports.frequencies = frequencies;\n"]}